{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 103, "column": 0}, "map": {"version":3,"sources":["file://D%3A/EMJE_projects/Teleworking-Tool/src/app/api/auth/signIn/route.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\nimport argon from \"argon2\"\r\nimport jwt from \"jsonwebtoken\"\r\nimport { NextResponse } from \"next/server\";\r\nimport { emit } from \"process\";\r\n\r\nexport async function POST(req: Request) {\r\n    const prisma = new PrismaClient()\r\n    const data = await req.json()\r\n     try{\r\n\r\n        const user = await prisma.user.findUnique(\r\n            {\r\n                where: {\r\n                    email: data.email\r\n                }\r\n            }\r\n        )\r\n\r\n        if (user) {\r\n\r\n            if (await argon.verify(user.password, data.password)) {\r\n                const token = jwt.sign(\r\n                    { email: data.email }, // Payload must be an object\r\n                    process.env.TOKEN!,   // Secret key\r\n                    { algorithm: 'HS256' } // Explicitly set the algorithm\r\n                )\r\n\r\n                return NextResponse.json(\r\n                    {\r\n                        \"status\": \"done! User successfuly signed in\",\r\n                        \"jwt\": token,\r\n                        \"type\": user.type,\r\n                        \"id\": user.id\r\n                    }\r\n                )\r\n            } else {\r\n                return NextResponse.json(\r\n                    {\r\n                        \"status\": \"error\",\r\n                        \"msg\": \"invalid password\"\r\n                    },\r\n                    {\r\n                        status :401\r\n                    }\r\n                )\r\n            }\r\n        } else {\r\n            return NextResponse.json(\r\n                {\r\n                    \"status\": \"error\",\r\n                    \"msg\": \"invalid user\"\r\n                },\r\n                {\r\n                    status :400\r\n                }\r\n            )\r\n        }\r\n    }\r\n    catch(e){\r\n        return NextResponse.json({\r\n                status: \"error\",\r\n                message: `Unknown error: ${e}`\r\n            });\r\n    }\r\n}"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAGO,eAAe,KAAK,GAAY;IACnC,MAAM,SAAS,IAAI,6HAAA,CAAA,eAAY;IAC/B,MAAM,OAAO,MAAM,IAAI,IAAI;IAC1B,IAAG;QAEA,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,UAAU,CACrC;YACI,OAAO;gBACH,OAAO,KAAK,KAAK;YACrB;QACJ;QAGJ,IAAI,MAAM;YAEN,IAAI,MAAM,qGAAA,CAAA,UAAK,CAAC,MAAM,CAAC,KAAK,QAAQ,EAAE,KAAK,QAAQ,GAAG;gBAClD,MAAM,QAAQ,uIAAA,CAAA,UAAG,CAAC,IAAI,CAClB;oBAAE,OAAO,KAAK,KAAK;gBAAC,GACpB,QAAQ,GAAG,CAAC,KAAK,EACjB;oBAAE,WAAW;gBAAQ,EAAE,+BAA+B;;gBAG1D,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;oBACI,UAAU;oBACV,OAAO;oBACP,QAAQ,KAAK,IAAI;oBACjB,MAAM,KAAK,EAAE;gBACjB;YAER,OAAO;gBACH,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;oBACI,UAAU;oBACV,OAAO;gBACX,GACA;oBACI,QAAQ;gBACZ;YAER;QACJ,OAAO;YACH,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACpB;gBACI,UAAU;gBACV,OAAO;YACX,GACA;gBACI,QAAQ;YACZ;QAER;IACJ,EACA,OAAM,GAAE;QACJ,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACjB,QAAQ;YACR,SAAS,CAAC,eAAe,EAAE,GAAG;QAClC;IACR;AACJ"}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}